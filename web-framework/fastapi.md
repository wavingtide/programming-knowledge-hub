# FastAPI

Refer to [documentation](https://fastapi.tiangolo.com/)

# Table of Contents
- [FastAPI](#fastapi)
- [Table of Contents](#table-of-contents)
- [API Concepts](#api-concepts)
- [Underlying and Relevant Technology](#underlying-and-relevant-technology)
- [Default Endpoints](#default-endpoints)
- [Installation](#installation)
- [Hello World](#hello-world)
- [API Inputs](#api-inputs)
  - [Setting Predefined Value](#setting-predefined-value)
  - [Path Parameters](#path-parameters)
  - [Query Parameters](#query-parameters)
  - [Request Body](#request-body)
  - [Intermediate: Query and Path Parameters Customization](#intermediate-query-and-path-parameters-customization)
    - [Customization options](#customization-options)
    - [Make Query Parameters Required](#make-query-parameters-required)
    - [Multiple Values for Query Parameters](#multiple-values-for-query-parameters)
  - [Intermediate: Request Body](#intermediate-request-body)
    - [Singular Type Body Parameter](#singular-type-body-parameter)
    - [Multiple Request Body Parameters](#multiple-request-body-parameters)
    - [Pydantic Model Customization](#pydantic-model-customization)
    - [Nested Pydantic Models](#nested-pydantic-models)
    - [Other Pydantic Model](#other-pydantic-model)
      - [Pydantic Model as List](#pydantic-model-as-list)
      - [Pydantic Model as Arbitrary Dictionary](#pydantic-model-as-arbitrary-dictionary)
    - [Extra Data Types from Pydantic](#extra-data-types-from-pydantic)
    - [Declare Request Example](#declare-request-example)
      - [Pydantic Extra Schema](#pydantic-extra-schema)
      - [Field Additional Argument](#field-additional-argument)
      - [`example` and `examples` in OpenAPI](#example-and-examples-in-openapi)
  - [Extra Data Types](#extra-data-types)
  - [Cookie](#cookie)
  - [Header](#header)
    - [Duplicate Headers](#duplicate-headers)
  - [Form Data and Request Files](#form-data-and-request-files)
    - [Form Data](#form-data)
    - [File](#file)
      - [`UploadFile`](#uploadfile)
    - [Using both Forms and Files](#using-both-forms-and-files)
- [API Output](#api-output)
  - [Response Body](#response-body)
    - [Other Response Body Type Annotations](#other-response-body-type-annotations)
    - [Response Body Customization](#response-body-customization)
  - [Response Status Code](#response-status-code)
    - [Error Handling](#error-handling)
      - [Customization](#customization)
        - [Add custom header](#add-custom-header)
        - [Add custom error](#add-custom-error)
        - [Override the default exception handlers](#override-the-default-exception-handlers)
- [Dependencies](#dependencies)
- [Miscellaneous](#miscellaneous)
  - [Typehint](#typehint)
  - [Python Tricks](#python-tricks)
    - [Order Function Parameters as We Need](#order-function-parameters-as-we-need)

# API Concepts
- HTTP Methods/Operations
  - `POST`: to create data
  - `GET`: to read data
  - `PUT`: to update data
  - `DELETE`: to delete data
- Path / endpoint / route
- Schema
- Server Gateway Interface
- HTTP Status Code
  - `100`: Information
  - `200`: Successful
  - `300`: Redirection
  - `400`: Client Error
  - `500`: Server Error

# Underlying and Relevant Technology
- API Schema Definition (API Paths, Possible parameters, JSON data schemas)
  - [OpenAPI](https://github.com/OAI/OpenAPI-Specification)
- [ASGI (Asynchronous Server Gateway Interface)](https://asgi.readthedocs.io/en/latest/)
  - [Starlette](https://www.starlette.io/)
- Data Validation
  - [Pydantic](https://pydantic-docs.helpmanual.io/)
- Documentation
  - [Swagger UI](https://github.com/swagger-api/swagger-ui)
  - [ReDoc](https://github.com/Rebilly/ReDoc)

# Default Endpoints
- `/docs`
- `/redoc`
- `/openapi.json`

# Installation
Create a virtual environment and run
``` bash
pip install fastapi
pip install "uvicorn[standard]"
```
If we want to install all dependencies
``` bash
pip install "fastapi[all]"
```

# Hello World
Add the following code to `main.py`
``` python
from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}
```

And run in terminal
``` bash
uvicorn main:app --reload
# main: filename
# app: fastapi object
# --reload: make the server restart after code change. Only use for development
```

# API Inputs
If the type is annotated, FastAPI will **convert** and **validate** the data input. FastAPI will raise error if the type doesn't match. FastAPI also add them to the autogenerated **documentation**.

Fastapi input-related features summary:
- Editor support
- Data 'parsing'
- Data validation
- Automatic documentation

The inputs can exist in several places:
- Path parameters
- Query parameters
- Request Body

## Setting Predefined Value 
To set the predefined value, we can define a class which inherits the [Enum](https://docs.python.org/3/library/enum.html) class. We can annotate the type of the function parameters as the defined class.

Example below also shows how `Enum` object works
``` python
class ModelName(str, Enum):  # also inherit str to ensure that the value is of type string
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"

app = FastAPI()

@app.get("/models/{model_name}") 
async def get_model(model_name: ModelName):
    print(type(model_name))  # <enum 'ModelName'>
    print(type(model_name.value))  # <class 'str'>
    print(ModelName.alexnet)  # ModelName.alexnet
    print(ModelName.alexnet.value)  # alexnet
    return model_name
```

The predefined value is documented.

![](https://i.imgur.com/qQdTjRr.png)


## Path Parameters
Path parameters appear in path, they are required and cannot be empty. 
``` python
@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}
```

Visit ` http://127.0.0.1:8000/items/foo` and it will return
``` python
{"item_id":"foo"}
```

## Query Parameters
Function parameters that are not part of path parameters are query parameters, they can be optional.

To make a function parameter optional, set a default value. (for type annotation, typehint it as `Union[str, None]` (or `str | None` in Python 3.10))

``` python
@app.get("/items/")
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]
```
The query appears as key-value set after `?` in the URL, separated by `&` characters. For example
``` bash
http://127.0.0.1:8000/items/?skip=0&limit=10
```

We can combine multiple path and query parameters.
``` python
@app.get("/users/{user_id}/items/{item_id}")
async def read_user_item(
    user_id: int, item_id: str, text: Union[str, None] = None, short: bool = False
    ):
    return {
        "item_id": item_id, 
        "owner_id": user_id
        "message": text,
        "bool": short}
```

## Request Body
A request body is data sent by client. FastAPI uses `BaseModel` from `pydantic` to define the data model. FastAPI will read the request body as JSON. Request body can be optional.
``` python
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: float

app = FastAPI()

@app.post("/item/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax:
        total_price = item.price + item.tax
    return {"total price": total_price}
```

The **request body** can be used with **path** and **query parameters**.
  1. Declared in path -> **path parameters**
  2. Singular type (like `int`, `float`, `str`, `bool`, etc) -> **query parameter**
  3. **Pydantic model** type -> **request body**

``` mermaid
flowchart TB;

    A("Is the function parameter in path?")
    B("Path parameters")
    C("What is the typehint of the function parameters")
    D("Query parameters")
    E("Request Body")
    
    A--"Yes"-->B;
    A--"No"-->C;
    C--"Singular type"-->D;
    C--"Pydantic model"-->E
```

``` python
@app.put("/items/{item_id}")
async def create_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result
```

## Intermediate: Query and Path Parameters Customization
We can set the default value of the function parameters as a `Query` or `Path` object. As it is an object, it comes with more customizations options. (both are subclass of `Param` class, which is subclass of Pydantic's `FieldInfo` class.)

We should use it with `Annotated` in type.
``` python
from fastapi import FastAPI, Path, Query
from typing import Union
from typing_extensions import Annotated

@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="Item ID")],
    q: Annotated[Union[str, None], Query(max_length=50)] = None
  ):
  return {"q": q}
```

This is the older method of FastAPI (before version `0.95.0`) which set the default value as the `Query` and `Path` object. It might not work if you call the function without FastAPI. You will need to pass the arguments to the functions.
``` python
from fastapi import FastAPI, Path, Query

@app.get("/items/{item_id}")
async def read_items(
    item_id: int = Path(title="Item ID")
    q: Union[str, None] = Query(default=None, max_length=50)
  ):
  return {"q": q}
```

### Customization options
`Query` and `Path` has the following arguments:
- `default`
- For string
  - `min_length`
  - `max_length`
  - `regex` (e.g."^exact_match*")
- For number
  - `ge` (greater equal)
  - `le` (less equal)
  - `gt` (greater than)
  - `lt` (less than)
- Other metadata
  - `title`
  - `description`
  - `alias` (can be used when the query name in URL is not valid Python variable name)
  - `deprecated=True`
  - `include_in_schema=False` (exclude from OpenAPI schema and documentation)

``` python
@app.get("/items/{item_id}")
async def read_items(
      q: Annotated[str, Query(title="Title", min_length=1)],
      item_id: Annotated[int, Path(gt=0, le=100)] = 50
    ):
    return {"q": q}
```

### Make Query Parameters Required
To make query parameters required, modify the typehint to not accept `None`, and don't set `default` in `Query` object.

Else, if the query parameters can accept `None`, do one of the following: 
- Set `default=...` (so called Ellipsis in Python)
- Run `from pydantic import Required` and set `default=Required`

``` python
@app.get("/items")
async def read_items(q: Annotated[int, Query(gt=0, lt=100)] = ...):
    return {"q": q}
```

### Multiple Values for Query Parameters
Set the typehint as a `List`. (Need to set default value as `Query` object to avoid fastapi identifying it as request body)

``` python
@app.get("/items")
async def read_items(q: Annotated[Union[List[str], None], Query()] = None):
    return {"q": q}
```
URL will look like
``` bash
http://localhost:8000/items/?q=foo&q=bar
```
Reponse
``` bash
{
  "q": [
    "foo",
    "bar"
  ]
}
```

## Intermediate: Request Body
### Singular Type Body Parameter
If we want to make a singular type parameter (`int`, `str`, etcs) a body parameter instead of a query parameter, we can use `Body`. It provides the same customizations and validations as `Query` and `Path`.
``` python
@app.post("/items")
async def update_item(price: Annotated[int, Body()]):
    return price
```
It will expect a single integer as request body in this case (e.g. `10`).

If there is only 1 singular type body parameters, it might be better to add `embed=True` to embed the body parameter.
``` python
@app.post("/items")
async def update_item(price: Annotated[int, Body(embed=True)]):
    return price
```

The expected FastAPI input will be like
``` python
{
  "price": 0
}
```

### Multiple Request Body Parameters
We can declare multiple body parameter.

``` python
class Item(BaseModel):
    name: str
    description: Union[str, None] = None

class User(BaseModel):
    username: str
    full_name: Union[str, None] = None

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User, price: Annotated[int, Body()]):
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```
When there are multiple body parameters,FastAPI will use the parameter names as keys of the request body . An example of valid inputs:
``` python
{
    "item": {
        "name": "Foo",
        "description": "The fighter"
    },
    "user": {
        "username": "wave",
        "full_name": "Wave"
    },
    "price": 100
}
```

### Pydantic Model Customization
We can set the default value of the function parameters as a `Field` object. It provides the same customizations and validations as `Query`, `Path` and `Body`. (note that `Field` is imported from `Pydantic` instead of `fastapi`.)
``` python
from pydantic import BaseModel, Field

class Item(BaseModel):
    name: str
    description: Union[str, None] = Field(default=None, max_length=300)
```

### Nested Pydantic Models
We can typehint the attribute of `Pydantic` model with another `Pydantic` model object.

``` python
class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    image: Union[Image, None] = None
```

An example of FastAPI expected input:
``` python
{
    "name": "Foo",
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
```

### Other Pydantic Model
#### Pydantic Model as List
Typehint the parameter using `List`.
``` python
class Image(BaseModel):
    url: HttpUrl
    name: str

@app.post("/images/multiple/")
async def create_multiple_images(images: List[Image]):
    return images
```

#### Pydantic Model as Arbitrary Dictionary
Typehint the parameter using `Dict`. Example: `Dict[str, float]` will accept str key and float value.
``` python
@app.post("/index-weights/")
async def create_index_weights(weights: Dict[str, float]):
    return weights
```

### Extra Data Types from Pydantic
Refer to [Pydantic documentation](https://pydantic-docs.helpmanual.io/usage/types/)

Example:
``` python
from pydantic import BaseModel, HttpUrl

class Image(BaseModel):
    url: HttpUrl
    name: str
```
### Declare Request Example
There are 3 ways to add example for request body.
#### Pydantic Extra Schema
``` python
class Item(BaseModel):
    name: str
    price: float

    class Config:
        schema_extra = {
            "example": {
                "name": "FastAPI",
                "price": 26.8
            }
        }

```
Check out [Pydantic schema customization](https://pydantic-docs.helpmanual.io/usage/schema/#schema-customization) for more information.

#### Field Additional Argument
``` python
class Item(BaseModel):
    name: str = Field(example="FastAPI")
    price: float = Field(example=26.8)
```

#### `example` and `examples` in OpenAPI
``` python
@app.post("/items")
async def update_item(item: Annotated[Union[Item, None], Body(
    example={
        "name": "FastAPI",
        "price": 26.8
    }
)]):
    return item
```

``` python
@app.post("/items")
async def update_item(item: Annotated[Union[Item, None], Body(
    examples={
        "first": {
            "summary": "first example",
            "description": "first description",
            "value": {
                "name": "FastAPI",
                "price": 26.8
            }
        },
        "invalid": {
            "summary": "example with invalid data",
            "value": {
                "name": "FastAPI",
                "price": "twenty six point eight"
        }
        }
    }
)]):
    return item
```
![](https://i.imgur.com/ij9NPwx.png)

## Extra Data Types
Refer to [link](https://fastapi.tiangolo.com/tutorial/extra-data-types/).
Example:
- `UUID`
- `datetime.datetime`
- `datetime.timedelta`

## Cookie
`Cookie` provides the same customizations and validations as `Query` and `Path`.
``` python
from fastapi import Cookie, FastAPI
from typing import Union
from typing_extensions import Annotated

app = FastAPI()

@app.get("/items/")
async def read_items(ads_id: Annotated[Union[str, None], Cookie(default=None)]):
    return {"ads_id": ads_id}
```

## Header
`Header` provides the same customizations and validations as `Query` and `Path`.
``` python
from fastapi import FastAPI, Header

app = FastAPI()

@app.get("/items/")
async def read_items(user_agent: Annotated[Union[str, None], Header(default=None)]):
    return {"User-Agent": user_agent}
```
Characteristics of headers:
- Usually standard headers are separated by a "hyphen" character (`-`).
- Case-insensitive
- Some HTTP proxies and server disallow the usage of headers with underscores

By default, `Header` will convert parameter names characters from underscore (`_`) to hyphen(`-`). Add `convert_underscores=False` to disable the automatic conversion.
``` python
strange_header: Annotated[Union[str, None], Header(default=None, convert_underscores=False)]
```

### Duplicate Headers
Set the typehint as a List.
``` python
@app.get("/items/")
async def read_items(x_token: Annotated[Union[List[str], None], Header(default=None)]):
    return {"X-Token values": x_token}
```

With that, the headers can be accepted with duplicates.
``` python
X-Token: foo
X-Token: bar
```

## Form Data and Request Files
*Requirements: `pip install python-multipart`*  

Data from forms is normally encoded using media type `application/x-www-form-urlencoded` when it doesn't include file, and encoded as `multipart/form-data` when the form include file.  

We cannot declare both form data and request body in the same path operation.

Both `Form` and `UploadFile` provides similar customizations and validations as `Query`, `Path` and `Body`.

### Form Data  
`Form` class inherits directly from `Body`

``` python
from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()

@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}
```

### File
`File` class inherits directly from `Form`. The file will be uploaded as 'form data'. The parameter type can be `bytes` or `UploadFile`. `UploadFile` class inherits directly from **Starlette**'s `UploadFile`.

With type `bytes`, **FastAPI** will read the file as bytes and store it in memory. (work well for small files)

With type `UploadFile`, **FastAPI** will read the file as a "spooled" file (stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk). (works well for large file)

``` python
from fastapi import FastAPI, File, UploadFile
from typing import Union
from typing_extensions import Annotated

app = FastAPI()

@app.post("/files/")
async def create_file(file: Annotated[Union[bytes, None], File(description="A file read as bytes")]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):  # don't need default value File() if specify type as UploadFile
    return {"filename": file.filename}
```
![](https://i.imgur.com/TT1mEYB.png)

To upload multiple files
``` python
async def create_files(files: Annotated[List[bytes], File(description="Multiple files as bytes")]):
    return {"file_sizes": [len(file) for file in files]}
```

``` python
@app.post("/uploadfiles/")
async def create_upload_files(files: Annotated[List[UploadFile], File(description="Multiple files as UploadFile")]):
    return {"filenames": [file.filename for file in files]}
```

#### `UploadFile`
Attributes of `UploadFile`:
- filename: `str`
- content_type: `str` (e.g. `image/jpeg`)
- file: [SpooledTemporaryFile](https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile)

Async methods of `UploadFile`:
- `write(data)`
- `read(size)`
- `seek(offset)`
- `close()`

In `async` path operation 
``` python
contents = await myfile.read()
```

In normal path operation, we can access the `UploadFile.file` directly
``` python
contents = myfile.file.read()
```

### Using both Forms and Files
We can define files and form fields at the same time using `File` and `Form`.
``` python
@app.post("/files/")
async def create_file(
    file: Annotated[bytes, File()], 
    fileb: Annotated[UploadFile, File()],
    token: Annotated[str, Form()]
):
    return {
        "file_size": len(file),
        "token": token,
        "fileb_content_type": fileb.content_type,
    }
```

# API Output
## Response Body
We can declare `Pydantic` model for response, just like request body. The response model should be declared as a **parameter of decorator method**, instead of path operation function return type (this helps to provide additional functionalities). It can perform field limiting.

If you have strict type checks (e.g. using `mypy`), you can declare the function return type as `Any`.

``` python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr  # pip install email-validator or pip install pydantic[email]

app = FastAPI()

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: Union[str, None] = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn):
    return user  # field limiting in action
```

![](https://i.imgur.com/Ho6siFK.png)

Notice that the response body is filtered based on response model.

To annotate the function type instead, we need to use inheritance.
``` python
class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: Union[str, None] = None


class UserIn(BaseUser):
    password: str


@app.post("/user/")
async def create_user(user: UserIn) -> BaseUser:
    return user
```
Do note that `response_model` in decorator method has a higher priority compared to function return type.

### Other Response Body Type Annotations
1. Return a `Response` directly
   ``` python
   from fastapi import FastAPI, Response
   from fastapi.response import JSONResponse, RedirectResponse
   
   app = FastAPI()

   @app.get("/portal")
   async def get_portal(redict: bool = False) -> Response:
       if redict:
           return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
       return JSONResponse(content={"message": "Here is your message"})
   ```
2. Return a `Response` subclass (e.g. `RedirectResponse`)
   ``` python
   @app.get("/portal")
   async def get_portal() -> RedirectResponse:
       return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
   ```
3. Disable response model (to disable validation by FastAPI)
   ``` python
   @app.get("/portal", response_model=None)
   async def get_portal() -> Union[Response, dict]:
       if redict:
           return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
       return content={"message": "Here is your message"}
   ```

### Response Body Customization
`FastAPI` has a lot of field customizations which can be used in `decorator method` (from [Pydantic](https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeldict)):
- `response_model_exclude_unset=True` - whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary
- `response_model_exclude_defaults=True` - whether fields which are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary
- `response_model_exclude_none=True` - whether fields which are equal to `None` should be excluded from the returned dictionary

One can also use the following parameters to include and exclude fields. However, it is recommended to defining multiple `Pydantic` models, instead of using these parameters.
- `response_model_include={set of str}`
- `response_model_include={set of str}`
- `response_model_by_alias`

Example of using `response_model_exclude_unset=True`
``` python
class Item(BaseModel):
    name: str
    description: Union[str, None] = "Default description"
    price: float

items = {
    "foo": {"name": "Foo", "price": 26.8}
}

@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]
```
In this case, `/items/foo` will not return the default value as there are unset.
```
{"name": "Foo", "price": 26.8}
```

## Response Status Code
We can specify the HTTP status code used for the response with the parameter `status_code` in the decorator. It can receive numeric status code, [http.HTTPStatus](https://docs.python.org/3/library/http.html#http.HTTPStatus) object or `fastapi.status` object (e.g. `fastapi.status.HTTP_201_CREATED`) or `starlette.status` object
``` python
@app.post("/items/", status_code=201)
async def create_item(name: str):
    return {"name": name}
```
![](https://i.imgur.com/2APnOiP.png)


### Error Handling
We can raise an error in the response to notify the client that there are problems (e.g. not enough privilege, non-existent item). To return HTTP responses with errors to the client, we can use `HTTPException`.
``` python
from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items[item_id]}
```

If `item_id` is not `foo`, it will return an error 404 with a response body.
``` shell
{
  "detail": "Item not found"
}
```

Do note that `detail` can be `dict` or `list` too.

#### Customization
##### Add custom header
Add `headers` in the `Exception` class.
``` python
async def read_item_header(item_id: str):
    if item_id not in items:
        raise HTTPException(
            status_code=404,
            detail="Item not found",
            headers={"X-Error": "There goes my error"},
        )
    return {"item": items[item_id]}
```

##### Add custom error
1. Create the custom exception object inheriting from class `Exception` 
2. Create an exception handler function using decorator `app.exception_handler`
3. Raise the error in the code
``` python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

class NewException(Exception):
    def __init__(self, name: str):
        self.name = name

app = FastAPI()

@app.exception_handler(NewException)
async def new_exception_handler(request: Request, exc: NewException):
    return JSONResponse(status_code=408, content={"message": f"Problem with {exc.name}"})

@app.get("/new/{name}")
async def get_item(name: str):
    if name == "newname":
        raise NewException(name=name)
    return name
```

Running `/new/newname` will return the following error with code `408`
``` shell
{
  "message": "Problem with newname"
}
```

##### Override the default exception handlers
FastAPI has some default exception handlers with default JSON responses. These handlers can be overwritten.
1. Create an exception handler function using decorator `app.exception_handler` for the default exception
2. Raise the error in the code

Example: Override `RequestValidationError` and `StarletteHTTPException`
``` python
from fastapi import FastAPI, HTTPException, status
from fastapi.encoders import jsonable_encoder
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse, PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, exc):
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSED_ENTITY,
        content=jsonable_encoder({"details": exc.errors(), "body": exc.body})
    )

@app.get("items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="What")
    return {"item_id": item_id}
```
Go to `/item/foo` will return
``` shell
1 validation error
path -> item_id
  value is not a valid integer (type=type_error.integer)
```

You can also access existing exception handlers from `fastapi.exception_handlers`
``` python
from fastapi.exception_handlers import (
    http_exception_handler, 
    request_validation_exception_handler
)

...

@app.exception_handler(StarletteHTTPException)
async def custom_http_exception_handler(request, exc):
    print("HTTP ERROR!")
    return await http_exception_handler(requst, exc)
```

Do note that we are handling `HTTPException` from Starlette instead of `HTTPException` from FastAPI. This is because both `HTTPException` is different. Handling Starlette's `HTTPException`, so that there are better support from Starlette.


# Dependencies
*Dependencies injection* - way for your code to declare things that it requires to work and use

This can be useful for shared logic or resources, enforce security.

We can do this in FastAPI using `Depends`.

``` python
from fastapi import Depends, FastAPI
from typing_extensions import Annotated

async def common_parameters(start: int = 0):
    return {"start": start}

@app.get("/item")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons
```

# Miscellaneous
## Typehint
Different Python versions have different typehinting mechanism, as Python improve their typehinting mechanism.

Example of defining optional list with string elements:
- For Python 3.6 and above:
`q: Union[List[str], None]`

- For Python 3.9 and above:
`q: Union[list[str], None]`

- For Python 3.10 and above:
`q: list[str] | None`

Example of importing `Annotated`:
- For Python 3.6 and above:
`from typing_extensions import Annotated`

- For Python 39 and above:
`from typing import Annotated`

## Python Tricks
### Order Function Parameters as We Need
``` python
def print(*, fruit: str='apple', vege: str):
    pass
```
